<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<title>Map All The Things With Mapbox GL</title>

<link rel="stylesheet" href="reveal/reset.css">
<link rel="stylesheet" href="reveal/reveal.css">
<link rel="stylesheet" href="reveal/theme/black.css">

<!-- Theme used for syntax highlighting of code -->
<link rel="stylesheet" href="reveal/plugin/highlight/monokai.css">

<!-- Mapbox GL -->
<script src='https://api.mapbox.com/mapbox-gl-js/v1.10.0/mapbox-gl.js'></script>
<link href='https://api.mapbox.com/mapbox-gl-js/v1.10.0/mapbox-gl.css' rel='stylesheet' />

<style>
.highlight {
  background-color: #ee0000;
  padding: 0 0.5rem;
  text-transform: none;
}

.fade {
  opacity: 0.3;
}

.move-marker {
  background-image: url('img/school.png');
  background-size: cover;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  cursor: pointer;
}

.mapboxgl-popup-content {
  color: black;
  font-size: 1.5rem;
  line-height: 1.8rem;
}

.reveal a.toronto-blue {
  color: #005695;
}
</style>
</head>
<body>
  <div class="reveal">
    <div class="map-container"></div>
    <div class="slides">
      <section data-background-color="#f7f7f7">
        <h1>Map All The Things</h1>
        <h2>With Mapbox GL</h2>
        <div class="stretch"></div>
        <p>
          <a class="toronto-blue" href="https://savageevan.com/">Evan Savage</a>
        </p>

        <aside class="notes">
          hi everyone!  welcome to Map All The Things with Mapbox GL.  i'm Evan Savage.
        </aside>
      </section>

      <section>
        <h2>about me</h2>
        <div>
          <img src="img/cfc-web-logo.png" height="200">
          <img src="img/share_toronto_twitter.jpg" height="200">
        </div>
        <img src="img/move.png" height="200">

        <aside class="notes">
          Code for Canada developer fellow working with City of Toronto on MOVE, which is a project
          to bring decades of the City's collision and traffic volume data into a single platform.
        </aside>
      </section>

      <section>
        <h2>civic data &#x2665; maps</h2>
        <img src="img/torontocivictransportation1915.jpg">

        <aside class="notes">
          <p>
            a lot of data governments (and people) care about is geospatial: you can and should
            put it on a map.  that's long been the case, as you can see from this 1915 map
            exploring how people get around Toronto.
          </p>
          <p>
            so geospatial data's nothing new.  what's new is the size of that data.
            on the MOVE project, for instance, we handle 1.5M collisions and 120M
            traffic volume readings.
          </p>
        </aside>
      </section>

      <section data-background-interactive data-map-id="schoolsWat">
        <h2><span class="highlight">wat</span></h2>

        <aside class="notes">
          <p>
            to put those numbers in context, here's a map of all schools and
            educational institutions in Toronto.
          </p>
          <p>
            everyone has seen a map like this.  it's slow to load, and impossible
            to tell what's going on - and there's only 1200 markers!
          </p>
        </aside>
      </section>

      <section>
        <h2>important questions</h2>
        <ul>
          <li>how can we <em>render</em> this much data?</li>
          <li>how can we <em>understand</em> this much data?</li>
          <li>how can we <em>process</em> this much data?</li>
        </ul>

        <aside class="notes">
          <p>
          so that's what this talk is about: how do we handle this much data?
          going to focus on three important questions.
          </p>
          <p>
            to handle larger datasets on maps, we need performant tools for
            rendering a lot of data at once.
            to understand these datasets, we need to carefully present it.
            and to handle especially large or complex datasets, we need to process it ahead
            of time to make these first two things possible.
          </p>
        </aside>
      </section>

      <section data-background-color="#ee0000">
        <h2>rendering</h2>
        <ul>
          <li>how can we <em>render</em> this much data?</li>
          <li class="fade">how can we <em>understand</em> this much data?</li>
          <li class="fade">how can we <em>process</em> this much data?</li>
        </ul>

        <aside class="notes">
          let's start with rendering: showing the data, period.
        </aside>
      </section>

      <section data-background-interactive data-map-id="helloWorld">
        <h2><span class="highlight">hello, world!</span></h2>

        <aside class="notes">
          to render data in MOVE, we use a library called Mapbox GL.
          it's not the only mapping library out there: Leaflet and OpenLayers.
          that said, it has a number of very useful features, as we'll see
          throughout this presentation.
        </aside>
      </section>

      <section>
        <h2>hello, Mapbox GL!</h2>

        <pre><code data-line-numbers="1,9|2,4|3-10|11" data-trim>
/* const basemapStyle = ... */
/* const $mapContainer = ... */
const options = {
  container: $mapContainer,
  dragRotate: false,
  keyboard: false,
  pitchWithRotate: false,
  renderWorldCopies: true,
  style: basemapStyle,
};
const map = new mapboxgl.Map(options);
        </code></pre>

        <aside class="notes">
          <p>
          as with most complex graphics, maps are often built out of layers.  the bottom-most
          layer is your basemap, with everything from continents to streets, parks, and buildings.
          </p>
          <p>
            in web mapping, you need a container div to store your map in.  Mapbox GL is no different.
          </p>
          <p>
            I've disabled a bunch of Mapbox GL's 3D navigation features for this talk - so I won't
            be showing those off, but with the right data they're really awesome.  finally we load all
            of these options into a map object.
          </p>
        </aside>
      </section>

      <section data-background-interactive data-map-id="helloToronto">
        <h2><span class="highlight">hello, Toronto!</span></h2>

        <aside class="notes">
          for this talk, I'll be focusing on data from Toronto.  that means we need to put
          Toronto in its rightful place at the center of the universe.  just as with other
          mapping libraries, you can set minimum and maximum zoom levels as well as a bounding
          box for panning.  unlikely that you need all zoom levels.
        </aside>
      </section>

      <section>
        <h2>exporting GeoJSON</h2>
        <img src="img/postgresql.svg" height="80">
        <img src="img/postgis.png" height="80">
        <pre><code data-line-numbers="2-8|9-17|18-22|1|23" data-trim>
COPY (
  WITH features AS (
    SELECT
      collision_id AS "id", geom,
      ksi, cyclist, pedestrian
    FROM collisions.events
    WHERE accdate >= now() - interval '3 year'
  ),
  geojson_features AS (
    SELECT jsonb_build_object(
      'type', 'Feature',
      'id', id,
      'geometry', ST_AsGeoJSON(geom)::jsonb,
      'properties', to_jsonb(features.*) - 'id' - 'geom'
    ) AS feature
    FROM features
  )
  SELECT jsonb_build_object(
    'type', 'FeatureCollection',
    'features', jsonb_agg(feature)
  ) AS feature_collection
  FROM geojson_features
) TO STDOUT WITH (HEADER FALSE);
        </code></pre>

        <aside class="notes">
          <p>
          next up: our dataset.  I'm using the collisions dataset from MOVE.  can't share this
          quite yet, but we're in the process of publishing through Open Data.
          </p>
          <p>
            I'm using the last 3 years, or about 150k collisions.  I pull those out of the
            database: in Mapbox GL, each feature needs an ID and a geometry; you can also
            add more properties.  we can then take those features and convert them to
            GeoJSON features using JSON functions in PostgreSQL.  then we can aggregate
            them all into a GeoJSON feature collection and dump that out.
          </p>
        </aside>
      </section>

      <section>
        <h2>exporting GeoJSON</h2>
        <img src="img/postgresql.svg" height="80">
        <img src="img/postgis.png" height="80">
        <pre><code data-noescape data-trim>
# save that SQL query as download_collisions.sql, then:
env $(xargs < "/home/ec2-user/cot-env.config") psql \
  -v ON_ERROR_STOP=1 \
  -f download_collisions.sql > collisions.geojson
        </code></pre>

        <aside class="notes">
          we store this SQL query in a file download_collisions.sql and run it, storing
          its output into a GeoJSON file.
        </aside>
      </section>

      <section>
        <h2>loading GeoJSON</h2>
        <pre><code data-line-numbers="3-6|1,8-11" data-trim>
let collisions = null;

async function getJson(url) {
  const response = await fetch(url);
  return response.json();
}

async function initMapbox() {
  collisions = await getJson('collisions.geojson');
  // ...
}
        </code></pre>

        <aside class="notes">
          we can then use the Fetch API available in modern browsers to load this
          data into a JavaScript object.
        </aside>
      </section>

      <section>
        <h2>using GeoJSON</h2>
        <pre><code data-line-numbers="1-5|2|3|7-19|8-10|13-18" data-trim>
map.addSource('collisions', {
  type: 'geojson',
  data: collisions,
  buffer: 0,
});

map.addLayer({
  id: 'collisionsPoints',
  source: 'collisions',
  type: 'circle',
  minzoom: ZOOM_LEVEL_3,
  maxzoom: ZOOM_LEVEL_0,
  paint: {
    'circle-color': COLOR_COLLISION_FILL,
    'circle-radius': 6.5,
    'circle-stroke-color': COLOR_COLLISION_STROKE,
    'circle-stroke-width': 1,
  },
});
        </code></pre>

        <aside class="notes">
          <p>
            now the fun part.  we start with source: GeoJSON type, using our newly loaded
            collisions data.  we then create layer: give it an ID, tie it to the collisions
            source, and use type circle - we're going to draw circles for each data point.
          </p>
          <p>
            in Mapbox GL, you can style your layers.  here we're telling it how to draw
            these circles: what color, what outline, how big.
          </p>

        </aside>
      </section>

      <section data-background-interactive data-map-id="collisionsPoints">
        <h2><span class="highlight">we can do better</span></h2>

        <aside class="notes">
          <p>
            takes a while to load: as we'll discuss in a bit, Mapbox GL is doing a lot of work up
            front to make sure we can navigate this smoothly once it loads.
          </p>
          <p></p>
            the result is pretty jarring, and in more ways than one.  first: that's 150k collisions
            over 3 years.  50k per year, 150 per day, 6 per hour.  even though most are minor, the
            human impact of this is staggering.
          </p>

          <p>
            this map doesn't do the dataset justice.  you can see there's a lot of collisions,
            but it's impossible to get much more than that.
          </p>

          <p>
            that said, once it loads, we can navigate pretty smoothly.  if you've ever tried loading
            150k div markers on a mapping library, it's not this smooth.
          </p>
        </aside>
      </section>

      <section>
        <h2>tiling</h2>
        <img class="stretch" src="img/tiling.png">

        <aside class="notes">
          <p>
            so what is Mapbox GL doing in those first few seconds?  it's building vector tiles on the
            fly!  pretty much every web map works this way: you divide your data into tiles at
            different zoom levels.  at each zoom level, you split the previous level's tiles into
            four smaller tiles.  you can then show different amounts of detail at different zoom levels.
          </p>
        </aside>
      </section>

      <section>
        <h2>your data on vector tiles</h2>
        <img class="fragment" src="img/flowchart-before.png">
        <img class="fragment" src="img/flowchart-after.png">

        <aside class="notes">
          <p>
          note I said vector tiles.  in days of yore, you'd get your data out of database or
          wherever as a shapefile, then you'd pick a style, then you'd render that data down
          to raster image tiles, and you'd serve those pre-rendered tiles to the client.  if
          you wanted to change the style, you had to rebuild your tiles from scratch.
          </p>
          <p>
            now, we still need to get the data - this time in GeoJSON format - but we can send
            that data down to the client, build vector tiles on the fly, then style them however
            we want!  this makes it much faster to iterate on web maps.
          </p>
        </aside>
      </section>

      <section data-background-color="#ee0000">
        <h2>understanding</h2>
        <ul>
          <li class="fade">how can we <em>render</em> this much data?</li>
          <li>how can we <em>understand</em> this much data?</li>
          <li class="fade">how can we <em>process</em> this much data?</li>
        </ul>

        <aside class="notes">
          so we can render data easily with Mapbox GL, and aside from a bit of loading time it
          works with midsized datasets quite well.  we're still not helping users understand
          this much data, though.  what can we do?  we'll explore three ways of dealing with
          this:
        </aside>
      </section>

      <section>
        <h2>what to do?</h2>
        <img class="stretch" src="img/clustering.png">

        <aside class="notes">
          clustering, where you group nearby points;
        </aside>
      </section>

      <section>
        <h2>what to do?</h2>
        <img class="stretch" src="img/heatmap.png">

        <aside class="notes">
          heatmaps, where you blur points together;
        </aside>
      </section>

      <section>
        <h2>what to do?</h2>
        <img class="stretch" src="img/visual-diff.png">

        <aside class="notes">
          and visual differentiation, where you style various parts of your data
          in different ways.
        </aside>
      </section>

      <section data-background-interactive data-map-id="collisionsClustered">
        <h2><span class="highlight">clustering</span></h2>

        <aside class="notes">
          group nearby points.  reduces clutter, but loses location precision!
        </aside>
      </section>

      <section>
        <h2>clustered sources</h2>

        <pre><code data-line-numbers="1-7|2-3|4,6" data-trim>
map.addSource('collisionsClustered', {
  type: 'geojson',
  data: collisions,
  cluster: true,
  clusterMaxZoom: ZOOM_LEVEL_0,
  clusterRadius: 30,
});
        </code></pre>

        <aside class="notes">
          same GeoJSON source as before.  add cluster option.  we can change the cluster radius
          to adjust the tradeoff between clutter and precision.
        </aside>
      </section>

      <section>
        <h2>clustered layers</h2>
        <ul>
          <li><code>'collisionsClustered'</code> for cluster circles</li>
          <li><code>'collisionsClusteredCount'</code> for cluster counts</li>
          <li><code>'collisionsUnclustered'</code> for point circles</li>
        </ul>
        <img src="img/cluster-screenshot.png">

        <aside class="notes">
          to display this, we now need 3 layers instead of 1.  the first two draw the clustered
          circles with a label showing how many points are in the cluster.  the last one handles
          points that are by themselves, not in a cluster.  we need two for the clusters because
          of how Mapbox GL styles work: we need to style the circle and the text separately.
        </aside>
      </section>

      <section data-background-interactive data-map-id="collisionsHeatmap">
        <h2><span class="highlight">heatmaps</span></h2>

        <aside class="notes">
          blur points together.  good for visualizing density, but doesn't work so
          well with sparse data.
        </aside>
      </section>

      <section>
        <h2>it's all a blur</h2>
				<div>
        	<img src="img/gaussian-kernel.png" height="400">
				</div>
        <a href="https://github.com/mapbox/mapbox-gl-js/blob/master/src/shaders/heatmap.vertex.glsl">heatmap shader</a>

        <aside class="notes">
          heatmaps work by blurring your points across a radius, then adding all those
          blurred points up.  by adding enough peaks and sides of peaks together, we get
          hotspots.  math aside, the key here for our purposes is that this can be done
          efficiently using GL shaders.
        </aside>
      </section>

      <section>
        <h2>it's all a blur</h2>

        <pre><code data-line-numbers="2-4|7|8-15|16-22|23-29|30-34" data-trim>
map.addLayer({
  id: 'collisionsHeatmap',
  source: 'collisions',
  type: 'heatmap',
  minzoom: ZOOM_LEVEL_3,
  maxzoom: ZOOM_LEVEL_0,
  paint: {
    'heatmap-color': [
      'interpolate',
      ['linear'],
      ['heatmap-density'],
      0, COLOR_COLLISION_HEATMAP_ZERO,
      0.5, COLOR_COLLISION_HEATMAP_HALF,
      1, COLOR_COLLISION_FILL,
    ],
    'heatmap-intensity': [
      'interpolate',
      ['linear'],
      ['zoom'],
      ZOOM_LEVEL_3, 0.33,
      ZOOM_LEVEL_2, 1,
    ],
    'heatmap-radius': [
      'interpolate',
      ['linear'],
      ['zoom'],
      ZOOM_LEVEL_3, 5,
      ZOOM_LEVEL_2, 10,
    ],
    'heatmap-weight': [
      'case',
      ['get', 'ksi'], 3,
      0.03,
    ],
  },
});
        </code></pre>

        <aside class="notes">
          <p>
            we can create a heatmap by using the heatmap layer type.
          </p>
          <p>
            we have a lot of things we can adjust here.  we can define a color ramp to blend
            seamlessly between heatmap intensity levels.  we can define a global intensity, which
            we increase as we zoom in to compensate for points spreading out.  same with that
            blur radius: we increase that too.
          </p>
          <p>
            allows for weighting of points: maybe some are more important than others (e.g. KSI)!
          </p>
        </aside>
      </section>

      <section data-background-interactive data-map-id="collisionsAllTogetherNow">
        <h2><span class="highlight">all together now</span></h2>

        <aside class="notes">
          using Mapbox GL, we can set "zoom breakpoints" and blend layers together.
          heatmap mainly useful zoomed out, clusters and points mainly useful closer in.
          blend between them as the user zooms.
        </aside>
      </section>

      <section>
        <h2>zoom breakpoints</h2>
        <pre><code data-line-numbers="4-6|4,8-14|21-23|21,25-31" data-trim>
map.addLayer({
  id: 'collisionsHeatmap',
  source: 'collisions',
  type: 'heatmap',
  minzoom: ZOOM_LEVEL_3,
  maxzoom: ZOOM_LEVEL_2 + 1,
  paint: {
    'heatmap-opacity': [
      'interpolate',
      ['linear'],
      ['zoom'],
      ZOOM_LEVEL_2, 0.8,
      ZOOM_LEVEL_2 + 1, 0,
    ],
    // ...
  },
});
map.addLayer({
  id: 'collisionsClustered',
  source: 'collisionsClustered',
  type: 'circle',
  minzoom: ZOOM_LEVEL_2,
  maxzoom: ZOOM_LEVEL_0,
  paint: {
    'circle-opacity': [
      'interpolate',
      ['linear'],
      ['zoom'],
      ZOOM_LEVEL_2, 0.2,
      ZOOM_LEVEL_2 + 1, 1,
    ],
    // ...
  },
});
        </code></pre>

        <aside class="notes">
          achieved by setting min and max zoom on different layers.  here we have the heatmap continue
          1 zoom level past its breakpoint - we fade the heatmap out over that zoom level using opacity.
          at the same time, we fade the clusters and points in to get a nice crossfade.
        </aside>
      </section>

      <section data-background-interactive data-map-id="collisionsVisualDiff">
        <h2><span class="highlight">visual differentiation</span></h2>

        <aside class="notes">
          focus attention to more important points: bigger, brighter, visually distinct.
          remember KSI: we want to draw attention to those, so we change the color, radius,
          font, and other visual features.
        </aside>
      </section>

      <section>
        <h2>data-driven styling</h2>
        <pre><code data-line-numbers="6-8" data-trim>
map.addSource('collisionsClustered', {
  type: 'geojson',
  data: collisions,
  cluster: true,
  clusterMaxZoom: ZOOM_LEVEL_0,
  clusterProperties: {
    ksiAny: ['any', ['get', 'ksi']],
  },
  clusterRadius: 30,
});
        </code></pre>

        <aside class="notes">
          first, we want to know if a cluster contains a KSI collision.  we use
          cluster properties to aggregate these together - ksiAny is true if any
          collision has the KSI flag set.
        </aside>
      </section>

      <section>
        <h2>data-driven styling</h2>
        <pre><code data-line-numbers="6-10|11-18|5" data-trim>
map.addLayer({
  // ...
  paint: {
    'circle-radius': [
      '*',
      [
        'case',
        ['get', 'ksiAny'], 1.25,
        1,
      ],
      [
        'step',
        ['get', 'point_count'],
        8,
        10, 10,
        100, 14,
        1000, 16,
      ],
    ],
    // ...
  },
});
        </code></pre>

        <aside class="notes">
          now we can use that aggregated property to style things.  here we want a bigger
          radius when ksiAny is true.  we can also increase the radius with the number of
          points in the cluster.  we can even multiply these two together to combine these
          effects.
        </aside>
      </section>

      <section>
        <h2>styling on the fly</h2>
        <img src="img/flowchart-after.png">
        <p><a href="https://www.interaction-design.org/literature/article/preattentive-visual-properties-and-how-to-use-them-in-information-visualization">
          pre-attentive properties
        </a></p>
        <p><small>color, size, shape, movement&hellip;</small></p>

        <aside class="notes">
          this is the power of vector tiles: you can quickly change the representation.
          instead of hours or days to regenerate tiles, it's a quick code change and page
          refresh, and you can see the result in seconds.  pre-attentive properties.
        </aside>
      </section>

      <section>
        <h2>styling on the fly</h2>
        <img src="img/flowchart-after.png">
        <p><a href="https://www.nngroup.com/articles/progressive-disclosure/">
          progressive disclosure
        </a></p>
        <p><small>on zoom, pan, hover, click&hellip;</small></p>

        <aside class="notes">
          progressive disclosure: don't need to show everything at once.  different details
          at different zoom levels.  show summary statistics visually, then allow users to
          load full details via hover or click interactions.  all helps manage the visual
          clutter.
        </aside>
      </section>

      <section data-background-color="#ee0000">
        <h2>processing</h2>
        <ul>
          <li class="fade">how can we <em>render</em> this much data?</li>
          <li class="fade">how can we <em>understand</em> this much data?</li>
          <li>how can we <em>process</em> this much data?</li>
        </ul>

        <aside class="notes">
          on to the last question: processing.
        </aside>
      </section>

      <section>
        <h2>we're done, right?</h2>
        <img src="img/collisions_loading.gif">

        <aside class="notes">
          <p>
            if you can load the whole dataset at once, GeoJSON layers actually work quite well!
          </p>
          <p>
            what if you can't, though?  loading 2.4 MB GeoJSON files is fine for a presentation,
            but I'm also only loading 3 years of data - we have data back to 1985, or 35 years ago.
            that would be roughly 20-30 MB, which is way too much for most web applications.
          </p>
        </aside>
      </section>

      <section>
        <h2>to the backend!</h2>
        <img src="img/flowchart-after-vector-backend.png">
        <p>
          preprocess <em>and</em> style on the fly!
        </p>

        <aside class="notes">
          this is again part of the power of vector tiles: since we're only sending geometry,
          not visual style, we can build vector tiles in the backend and continue to style them
          in the frontend.  best of both worlds.
        </aside>
      </section>

      <section>
        <h2>prebuilt tiles: <code>tippecanoe</code></h2>
        <pre class="bash"><code data-trim>
tippecanoe \
  -o collisions.mbtiles \
  -l collisionsClustered \
  -Z10 -z16 \
  --accumulate-attribute=ksiAny:any \
  --cluster-densest-as-needed \
  -r1 \
  collisions.geojson
        </code></pre>
        <aside class="notes">
          one tool for buliding vector tiles is tippecanoe, also maintained by Mapbox.
          great for absolutely massive datasets!  lots of options for simplifying and
          culling features to reduce tileset size.
        </aside>
      </section>

      <section>
        <h2>prebuilt tiles: <code>.mbtiles</code></h2>
        <pre class="sql"><code data-trim>
$ sqlite3 collisions.mbtiles
sqlite> .schema
CREATE TABLE metadata (name text, value text);
CREATE TABLE tiles (
  zoom_level integer,
  tile_column integer,
  tile_row integer,
  tile_data blob
);
CREATE UNIQUE INDEX name on metadata (name);
CREATE UNIQUE INDEX tile_index on tiles (
  zoom_level, tile_column, tile_row
);
        </code></pre>
        <p>
          <a href="https://github.com/chelm/mbtiles-server"><code>mbtiles-server</code></a>
        </p>

        <aside class="notes">
          tippecanoe produces an mbtiles file.  this is just a sqlite database that
          maps (z, x, y), or (zoom, column, row), tile coordinates to tile data.
          with tools like mbtiles-server, you can serve mbtiles files out of the box.
        </aside>
      </section>

      <section>
        <h2>prebuilt tiles: <code>mb-util</code></h2>
        <pre class="bash"><code data-trim>
$ mb-util \
  --image_format=pbf --silent \
  collisions.mbtiles /data/tiles/collisions

# wait a while...

$ ls /data/tiles/collisions
10  11  12  13  14  15  16  metadata.json

$ ls /data/tiles/collisions/10
281  284  285  286  287  288  296  301

$ ls /data/tiles/collisions/10/281
375.pbf  376.pbf
        </code></pre>
        <aside class="notes">
          if you don't want to launch a separate server just for some map tiles, there's
          mb-util.  this tool extracts individual tiles from the mbtiles archive, and
          stores them all into a nested directory structure.  with your tiles as static
          files, you can host them pretty much anywhere and behind pretty much anything.
        </aside>
      </section>

      <section>
        <h2>dynamic tiles</h2>
        <img class="stretch" src="img/dynamic-vector.png">

        <aside class="notes">
          with newer versions of PostgreSQL and PostGIS, you can even generate vector
          tiles directly from the database.  this opens up even more possibilities for
          prototyping and iterating on backend vector tile pipelines.
        </aside>
      </section>

      <section>
        <h2>important questions</h2>
        <ul>
          <li><em>render</em>: Mapbox GL</li>
          <li>
            <em>understand</em>: progressive disclosure, pre-attentive properties,
            contextual information, etc.
          </li>
          <li>
            <em>process</em>: PostgreSQL / PostGIS, tippecanoe, mbutil,
            cron / Airflow, etc.
          </li>
        </ul>

        <aside class="notes">
          <p>
          so we've seen how we can render lots of data in a map.  we've also seen how we
          can present that data so our users can understand it.  finally, we've seen how
          we can move vector tile processing to the backend, so that we can handle even
          larger datasets.
          </p>
          <p>
            this is just the beginning; there's lots of other tools and techniques I didn't
            have time to cover.  hopefully this gives you a useful place to start, though.
          </p>
        </aside>
      </section>

      <section data-background-color="#f7f7f7">
        <h1>Map All The Things</h1>
        <h2>With Mapbox GL</h2>
        <div class="stretch"></div>
        <p>
          <a href="https://savageevan.com/">Evan Savage</a>
        </p>

        <aside class="notes">
          thanks for listening, and happy mapping!
        </aside>
      </section>
    </div>
  </div>
<!-- END OF SLIDES -->

<script src="reveal/reveal.js"></script>
<script src="reveal/plugin/notes/notes.js"></script>
<script src="reveal/plugin/highlight/highlight.js"></script>

<script>
const BOUNDS_TORONTO = new mapboxgl.LngLatBounds(
  new mapboxgl.LngLat(-79.639264937, 43.580995995),
  new mapboxgl.LngLat(-79.115243191, 43.855457183),
);
const COLOR_COLLISION_HEATMAP_ZERO = 'rgba(244, 227, 219, 0)';
const COLOR_COLLISION_HEATMAP_HALF = '#f39268';
const COLOR_COLLISION_FILL = '#ef4848';
const COLOR_COLLISION_STROKE = '#773333';
const ZOOM_LEVEL_3 = 10;
const ZOOM_LEVEL_2 = 14;
const ZOOM_LEVEL_1 = 17;
const ZOOM_LEVEL_0 = 19;

let collisions = null;
let basemapStyle = null;
let map = null;
let schools = null;

async function getJson(url) {
  const response = await fetch(url);
  return response.json();
}

async function initMapbox() {
  const [
    collisionsData,
    metadata,
    root,
    schoolsData,
  ] = await Promise.all([
    getJson('data/collisions.geojson'),
    getJson('data/metadata.json'),
    getJson('data/root.json'),
    getJson('data/schools.geojson'),
  ]);

  basemapStyle = JSON.parse(JSON.stringify(root));
  basemapStyle.sources.esri = {
    type: 'vector',
    scheme: 'xyz',
    tilejson: metadata.tilejson || '2.0.0',
    format: (metadata.tileInfo && metadata.tileInfo.format) || 'pbf',
    maxzoom: 15,
    tiles: [
      `${basemapStyle.sources.esri.url}${metadata.tiles[0]}`,
    ],
    description: metadata.description || '',
    name: metadata.name,
  };

  collisions = collisionsData;
  schools = schoolsData;
}

class MapOptions {
  // HELPERS

  static _common() {
    return {
      dragRotate: false,
      keyboard: false,
      pitchWithRotate: false,
      renderWorldCopies: true,
      style: basemapStyle,
    };
  }

  static _commonToronto() {
    return {
      ...MapOptions._common(),
      center: BOUNDS_TORONTO.getCenter(),
      maxBounds: BOUNDS_TORONTO,
      maxZoom: ZOOM_LEVEL_0,
      minZoom: ZOOM_LEVEL_3,
      renderWorldCopies: false,
      zoom: ZOOM_LEVEL_3,
    };
  }

  static get(mapId) {
    return MapOptions[mapId]();
  }

  static getContainer() {
    const $reveal = Reveal.getRevealElement();
    const i = Reveal.getSlidePastCount() + 1;
    const selector = `.slide-background:nth-child(${i}) > .slide-background-content`;
    return $reveal.querySelector(selector);
  }

  // MAP FUNCTIONS

  static collisionsAllTogetherNow() {
    return MapOptions._commonToronto();
  }

  static collisionsClustered() {
    return MapOptions._commonToronto();
  }

  static collisionsHeatmap() {
    return MapOptions._commonToronto();
  }

  static collisionsPoints() {
    return MapOptions._commonToronto();
  }

  static collisionsVisualDiff() {
    return {
      ...MapOptions._commonToronto(),
      maxZoom: ZOOM_LEVEL_0,
      minZoom: ZOOM_LEVEL_2,
      zoom: ZOOM_LEVEL_2,
    };
  }

  static helloToronto() {
    return MapOptions._commonToronto();
  }

  static helloWorld() {
    return MapOptions._common();
  }

  static schoolsThatsBetter() {
    return {
      ...MapOptions._commonToronto(),
      zoom: ZOOM_LEVEL_2,
    };
  }

  static schoolsWat() {
    return MapOptions._commonToronto();
  }
}

class MapInit {
  // HELPERS

  static init(mapId, map) {
    return MapInit[mapId](map);
  }

  // MAP FUNCTIONS

  static collisionsAllTogetherNow(map) {
    map.addSource('collisions', {
      type: 'geojson',
      data: collisions,
      buffer: 0,
    });
    map.addSource('collisionsClustered', {
      type: 'geojson',
      data: collisions,
      cluster: true,
      clusterMaxZoom: ZOOM_LEVEL_0,
      clusterRadius: 30,
    });

    map.addLayer({
      id: 'collisionsHeatmap',
      source: 'collisions',
      type: 'heatmap',
      minzoom: ZOOM_LEVEL_3,
      maxzoom: ZOOM_LEVEL_2 + 1,
      paint: {
        'heatmap-color': [
          'interpolate',
          ['linear'],
          ['heatmap-density'],
          0, COLOR_COLLISION_HEATMAP_ZERO,
          0.5, COLOR_COLLISION_HEATMAP_HALF,
          1, COLOR_COLLISION_FILL,
        ],
        'heatmap-intensity': [
          'interpolate',
          ['linear'],
          ['zoom'],
          ZOOM_LEVEL_3, 0.33,
          ZOOM_LEVEL_2, 1,
        ],
        'heatmap-opacity': [
          'interpolate',
          ['linear'],
          ['zoom'],
          ZOOM_LEVEL_2, 0.8,
          ZOOM_LEVEL_2 + 1, 0,
        ],
        'heatmap-radius': [
          'interpolate',
          ['linear'],
          ['zoom'],
          ZOOM_LEVEL_3, 5,
          ZOOM_LEVEL_2, 10,
        ],
        'heatmap-weight': [
          'case',
          ['get', 'ksi'], 3,
          0.03,
        ],
      },
    });
    map.addLayer({
      id: 'collisionsClustered',
      source: 'collisionsClustered',
      type: 'circle',
      minzoom: ZOOM_LEVEL_2,
      maxzoom: ZOOM_LEVEL_0,
      filter: ['has', 'point_count'],
      paint: {
        'circle-color': COLOR_COLLISION_FILL,
        'circle-opacity': [
          'interpolate',
          ['linear'],
          ['zoom'],
          ZOOM_LEVEL_2, 0.2,
          ZOOM_LEVEL_2 + 1, 1,
        ],
        'circle-radius': [
          'step',
          ['get', 'point_count'],
          8,
          10, 10,
          100, 14,
          1000, 16,
        ],
        'circle-stroke-color': COLOR_COLLISION_STROKE,
        'circle-stroke-width': 1,
      },
    });
    map.addLayer({
      id: 'collisionsClusteredCount',
      source: 'collisionsClustered',
      type: 'symbol',
      minzoom: ZOOM_LEVEL_2,
      maxzoom: ZOOM_LEVEL_0,
      filter: ['has', 'point_count'],
      layout: {
        'text-field': '{point_count_abbreviated}',
        'text-font': ['Ubuntu Regular'],
        'text-size': 12
      },
      paint: {
        'text-color': COLOR_COLLISION_STROKE,
        'text-opacity': [
          'interpolate',
          ['linear'],
          ['zoom'],
          ZOOM_LEVEL_2, 0.2,
          ZOOM_LEVEL_2 + 1, 1,
        ],
      }
    });
    map.addLayer({
      id: 'collisionsUnclustered',
      source: 'collisionsClustered',
      type: 'circle',
      minzoom: ZOOM_LEVEL_2,
      maxzoom: ZOOM_LEVEL_0,
      filter: ['!', ['has', 'point_count']],
      paint: {
        'circle-color': COLOR_COLLISION_FILL,
        'circle-opacity': [
          'interpolate',
          ['linear'],
          ['zoom'],
          ZOOM_LEVEL_2, 0.2,
          ZOOM_LEVEL_2 + 1, 1,
        ],
        'circle-radius': 4,
        'circle-stroke-color': COLOR_COLLISION_STROKE,
        'circle-stroke-width': 1,
      },
    });
  }

  static collisionsClustered(map) {
    map.addSource('collisionsClustered', {
      type: 'geojson',
      data: collisions,
      cluster: true,
      clusterMaxZoom: ZOOM_LEVEL_0,
      clusterRadius: 30,
    });
    map.addLayer({
      id: 'collisionsClustered',
      source: 'collisionsClustered',
      type: 'circle',
      minzoom: ZOOM_LEVEL_3,
      maxzoom: ZOOM_LEVEL_0,
      filter: ['has', 'point_count'],
      paint: {
        'circle-color': COLOR_COLLISION_FILL,
        'circle-radius': [
          'step',
          ['get', 'point_count'],
          8,
          10, 10,
          100, 14,
          1000, 16,
        ],
        'circle-stroke-color': COLOR_COLLISION_STROKE,
        'circle-stroke-width': 1,
      },
    });
    map.addLayer({
      id: 'collisionsClusteredCount',
      source: 'collisionsClustered',
      type: 'symbol',
      minzoom: ZOOM_LEVEL_3,
      maxzoom: ZOOM_LEVEL_0,
      filter: ['has', 'point_count'],
      layout: {
        'text-field': '{point_count_abbreviated}',
        'text-font': ['Ubuntu Regular'],
        'text-size': 12
      },
      paint: {
        'text-color': COLOR_COLLISION_STROKE,
      }
    });
    map.addLayer({
      id: 'collisionsUnclustered',
      source: 'collisionsClustered',
      type: 'circle',
      minzoom: ZOOM_LEVEL_3,
      maxzoom: ZOOM_LEVEL_0,
      filter: ['!', ['has', 'point_count']],
      paint: {
        'circle-color': COLOR_COLLISION_FILL,
        'circle-radius': 4,
        'circle-stroke-color': COLOR_COLLISION_STROKE,
        'circle-stroke-width': 1,
      },
    });
  }

  static collisionsHeatmap(map) {
    map.addSource('collisions', {
      type: 'geojson',
      data: collisions,
      buffer: 0,
    });
    map.addLayer({
      id: 'collisionsHeatmap',
      source: 'collisions',
      type: 'heatmap',
      minzoom: ZOOM_LEVEL_3,
      maxzoom: ZOOM_LEVEL_0,
      paint: {
        'heatmap-color': [
          'interpolate',
          ['linear'],
          ['heatmap-density'],
          0, COLOR_COLLISION_HEATMAP_ZERO,
          0.5, COLOR_COLLISION_HEATMAP_HALF,
          1, COLOR_COLLISION_FILL,
        ],
        'heatmap-intensity': [
          'interpolate',
          ['linear'],
          ['zoom'],
          ZOOM_LEVEL_3, 0.33,
          ZOOM_LEVEL_2, 1,
        ],
        'heatmap-radius': [
          'interpolate',
          ['linear'],
          ['zoom'],
          ZOOM_LEVEL_3, 5,
          ZOOM_LEVEL_2, 10,
        ],
        'heatmap-weight': [
          'case',
          ['get', 'ksi'], 3,
          0.03,
        ],
      },
    });
  }

  static collisionsPoints(map) {
    map.addSource('collisions', {
      type: 'geojson',
      data: collisions,
      buffer: 0,
    });
    map.addLayer({
      id: 'collisionsPoints',
      source: 'collisions',
      type: 'circle',
      minzoom: ZOOM_LEVEL_3,
      maxzoom: ZOOM_LEVEL_0,
      paint: {
        'circle-color': COLOR_COLLISION_FILL,
        'circle-radius': 6.5,
        'circle-stroke-color': COLOR_COLLISION_STROKE,
        'circle-stroke-width': 1,
      },
    });
  }

  static collisionsVisualDiff() {
    map.addSource('collisionsClustered', {
      type: 'geojson',
      data: collisions,
      cluster: true,
      clusterMaxZoom: ZOOM_LEVEL_0,
      clusterProperties: {
        ksiAny: ['any', ['get', 'ksi']],
      },
      clusterRadius: 30,
    });
    map.addLayer({
      id: 'collisionsClustered',
      source: 'collisionsClustered',
      type: 'circle',
      minzoom: ZOOM_LEVEL_2,
      maxzoom: ZOOM_LEVEL_0,
      filter: ['has', 'point_count'],
      paint: {
        'circle-color': [
          'case',
          ['get', 'ksiAny'], '#272727',
          COLOR_COLLISION_FILL,
        ],
        'circle-radius': [
          '*',
          [
            'case',
            ['get', 'ksiAny'], 1.25,
            1,
          ],
          [
            'step',
            ['get', 'point_count'],
            8,
            10, 10,
            100, 14,
            1000, 16,
          ],
        ],
        'circle-stroke-color': [
          'case',
          ['get', 'ksiAny'], '#fff',
          COLOR_COLLISION_STROKE,
        ],
        'circle-stroke-width': [
          'case',
          ['get', 'ksiAny'], 2,
          1,
        ],
      },
    });
    map.addLayer({
      id: 'collisionsClusteredCount',
      source: 'collisionsClustered',
      type: 'symbol',
      minzoom: ZOOM_LEVEL_2,
      maxzoom: ZOOM_LEVEL_0,
      filter: ['has', 'point_count'],
      layout: {
        'text-field': '{point_count_abbreviated}',
        'text-font': [
          'case',
          ['get', 'ksiAny'], ['literal', ['Ubuntu Bold']],
          ['literal', ['Ubuntu Regular']],
        ],
        'text-size': 12
      },
      paint: {
        'text-color': [
          'case',
          ['get', 'ksiAny'], '#fff',
          COLOR_COLLISION_STROKE,
        ],
      }
    });
    map.addLayer({
      id: 'collisionsUnclustered',
      source: 'collisionsClustered',
      type: 'circle',
      minzoom: ZOOM_LEVEL_2,
      maxzoom: ZOOM_LEVEL_0,
      filter: ['!', ['has', 'point_count']],
      paint: {
        'circle-color': [
          'case',
          ['get', 'ksi'], '#272727',
          COLOR_COLLISION_FILL,
        ],
        'circle-radius': [
          'case',
          ['get', 'ksi'], 6,
          4,
        ],
        'circle-sort-key': [
          'case',
          ['get', 'ksi'], 1,
          0,
        ],
        'circle-stroke-color': [
          'case',
          ['get', 'ksi'], '#fff',
          COLOR_COLLISION_STROKE,
        ],
        'circle-stroke-width': [
          'case',
          ['get', 'ksiAny'], 2,
          1,
        ],
      },
    });
  }

  static helloToronto(map) {}

  static helloWorld(map) {}

  static schoolsThatsBetter(map) {
    let popup = null;

    schools.features.forEach((feature) => {
      var $marker = document.createElement('div');
      $marker.className = 'move-marker';
      const marker = new mapboxgl.Marker($marker)
        .setLngLat(feature.geometry.coordinates)
        .addTo(map);

      $marker.addEventListener('click', function() {
        if (popup !== null) {
          popup.remove();
        }
        popup = new mapboxgl.Popup({ offset: 20 })
          .setText(feature.properties.NAME);
        marker.setPopup(popup);
      });
    });
  }

  static schoolsWat(map) {
    schools.features.forEach((feature) => {
      new mapboxgl.Marker()
        .setLngLat(feature.geometry.coordinates)
        .addTo(map);
    });
  }
}

function removeMap() {
  if (map !== null) {
    map.remove();
    map = null;
  }
}

function loadMap() {
  const $currentSlide = Reveal.getCurrentSlide();
  const { mapId } = $currentSlide.dataset;
  if (mapId !== undefined) {
    const $mapContainer = MapOptions.getContainer();
    const options = MapOptions.get(mapId);

    console.log(mapId, options);
    map = new mapboxgl.Map({
      container: $mapContainer,
      ...options,
    });
    map.on('load', () => MapInit.init(mapId, map));
  }
}

function initReveal() {
  Reveal.initialize({
    center: false,
    hash: true,
    plugins: [RevealHighlight, RevealNotes],
  });

  Reveal.addEventListener('slidechanged', function(evt) {
    removeMap();
    loadMap();
  });
  Reveal.addEventListener('overviewshown', removeMap);
  Reveal.addEventListener('overviewhidden', loadMap);
}

async function main() {
  await initMapbox();
  initReveal();
}

main();
</script>
</body>
</html>
